{-# OPTIONS --cubical --erasure --rewriting #-}
open import Agda.Primitive renaming (Set to Type; SetÏ‰ to TypeÏ‰)
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Axiom.Extensionality.Propositional
open import Data.Product
import Cubical.Foundations.Prelude as ğŸ§Š
import Cubical.Foundations.CartesianKanOps as ğŸ§Š
{-# BUILTIN REWRITE _â‰¡_ #-}

-- Investigating the erasure modality
module Erasure where

private variable
  a b : Level
  A : Type a

-- The erased path induction principle Jâ‚€

Jâ‚€-type =
  âˆ€ {a b} {@0 A : Type a} {@0 x : A} (B : (@0 y : A) â†’ @0 x â‰¡ y â†’ Type b)
  â†’ {@0 y : A} (@0 p : x â‰¡ y) â†’ B x refl â†’ B y p

-- The Erased monadic modality

record Erased (@0 A : Type a) : Type a where
  constructor [_]
  field
    @0 erased : A

open Erased

Î· : {@0 A : Type a} â†’ A â†’ Erased A
Î· x = [ x ]

Î¼ : {@0 A : Type a} â†’ Erased (Erased A) â†’ Erased A
Î¼ [ [ x ] ] = [ x ]

-- Paths (Erased A) â†’ Erased (Paths A)
erased-cong : âˆ€ {a} {@0 A : Type a} {@0 x y : A} â†’ [ x ] â‰¡ [ y ] â†’ Erased (x â‰¡ y)
erased-cong p = [ cong erased p ]

-- Erased (Paths A) â†’ Paths (Erased A) ("erasure extensionality")
[]-cong-type = âˆ€ {a} {@0 A : Type a} {@0 x y : A} â†’ Erased (x â‰¡ y) â†’ [ x ] â‰¡ [ y ]

-- Jâ‚€ and []-cong (with their respective computation rules) are interderivable

module Jâ‚€â†’[]-cong where
  postulate
    Jâ‚€ : Jâ‚€-type
    Jâ‚€-refl
      : âˆ€ {a b} {@0 A : Type a} {@0 x : A} (B : (@0 y : A) â†’ @0 x â‰¡ y â†’ Type b) (r : B x refl)
      â†’ Jâ‚€ B refl r â‰¡ r
    {-# REWRITE Jâ‚€-refl #-}

  []-cong : []-cong-type
  []-cong {x} [ p ] = Jâ‚€ (Î» y _ â†’ [ x ] â‰¡ [ y ]) p refl

  []-cong-refl
    : âˆ€ {a} {@0 A : Type a} {@0 x : A}
    â†’ []-cong {x = x} [ refl ] â‰¡ refl
  []-cong-refl = refl

module []-congâ†’Jâ‚€ where
  postulate
    []-cong : []-cong-type
    []-cong-refl
      : âˆ€ {a} {@0 A : Type a} {@0 x : A}
      â†’ []-cong {x = x} [ refl ] â‰¡ refl
    {-# REWRITE []-cong-refl #-}

  --                        []-cong                        Î¼
  -- Erased (Paths (Erased A)) â†’ Paths (Erased (Erased A)) â†’ Paths (Erased A)
  stable-â‰¡ : âˆ€ {@0 A : Type a} {x y : Erased A} â†’ Erased (x â‰¡ y) â†’ x â‰¡ y
  stable-â‰¡ p = cong Î¼ ([]-cong p)

  --         Î·               []-cong          erased-cong
  -- Paths A â†’ Erased (Paths A) â†’ Paths (Erased A) â†’ Erased (Paths A)
  --           Erased (Paths A)           â†’          Erased (Paths A)
  --                                      id
  []-cong-section'
    : âˆ€ {@0 A : Type a} {@0 x y : A} (p : x â‰¡ y)
    â†’ erased-cong ([]-cong (Î· p)) â‰¡ Î· p
  []-cong-section' refl = refl

  -- We can cancel out Î· by unique elimination and stability of paths in Erased
  []-cong-section
    : âˆ€ {@0 A : Type a} {@0 x y : A} (@0 p : x â‰¡ y)
    â†’ erased-cong ([]-cong [ p ]) â‰¡ [ p ]
  []-cong-section p = stable-â‰¡ [ []-cong-section' p ]

  Jâ‚€ : Jâ‚€-type
  Jâ‚€ B {y} p r = subst (Î» ([ p ]) â†’ B y p) ([]-cong-section p) b'
    where
      b' : B y (cong erased ([]-cong [ p ]))
      b' = J (Î» ([ y ]) p â†’ B y (cong erased p)) ([]-cong [ p ]) r

  Jâ‚€-refl
    : âˆ€ {a b} {@0 A : Type a} {@0 x : A} (B : (@0 y : A) â†’ @0 x â‰¡ y â†’ Type b) (r : B x refl)
    â†’ Jâ‚€ B refl r â‰¡ r
  Jâ‚€-refl B r = refl

-- Function extensionality implies erasure extensionality
module funextâ†’[]-cong where
  postulate
    funext : âˆ€ {a b} â†’ Extensionality a b

  -- Direct proof, extracted from "Logical properties of a modality for erasure" (Danielsson 2019)

  -- id : Paths (Erased A) â†’ Paths (Erased A)
  --    â†’ {funext}
  --      Paths (Paths (Erased A) â†’ Erased A)
  --    â†’ {uniquely eliminating}
  --      Paths (Erased (Paths (Erased A)) â†’ Erased A)
  --    â†’ {apply p}
  --      Paths (Erased A)
  stable-â‰¡ : âˆ€ {@0 A : Type a} {x y : Erased A} â†’ Erased (x â‰¡ y) â†’ x â‰¡ y
  stable-â‰¡ {A} {x} {y} [ p ] =
    cong (Î» (f : x â‰¡ y â†’ Erased A) â†’ [ f p .erased ])
         (funext (Î» (p : x â‰¡ y) â†’ p))

  --                  Î·                        stable-â‰¡
  -- Erased (Paths A) â†’ Erased (Paths (Erased A)) â†’ Paths (Erased A)
  []-cong : []-cong-type
  []-cong [ p ] = stable-â‰¡ [ cong Î· p ]

  -- Alternative proof: ignoring some details, the types of funext and []-cong look very similar:
  --   funext  : Functions (Paths A) â†’ Paths (Functions A)
  --   []-cong : Erased    (Paths A) â†’ Paths (Erased    A)
  --
  -- If we have inductive types with erased constructors, then we can
  -- present erasure as an *open subtopos* generated by the subterminal
  -- object with a single erased point:

  data None : Type where
    @0 none : None

  â—‹'_ : Type a â†’ Type a
  â—‹' A = None â†’ A

  â—‹_ : â—‹' Type a â†’ Type a
  â—‹ A = (n : None) â†’ A n

  Eâ†’â—‹ : {A : â—‹' Type a} â†’ Erased (A none) â†’ â—‹ A
  Eâ†’â—‹ [ a ] none = a

  â—‹â†’E : {A : â—‹' Type a} â†’ â—‹ A â†’ Erased (A none)
  â—‹â†’E f = [ f none ]

  Eâ†’â—‹â†’E : {A : â—‹' Type a} â†’ (a : Erased (A none)) â†’ â—‹â†’E (Eâ†’â—‹ {A = A} a) â‰¡ a
  Eâ†’â—‹â†’E _ = refl

  -- We don't actually need this
  â—‹â†’Eâ†’â—‹ : {A : â—‹' Type a} â†’ (f : â—‹ A) â†’ Eâ†’â—‹ (â—‹â†’E f) â‰¡ f
  â—‹â†’Eâ†’â—‹ f = funext (Eâ†’â—‹ [ refl {x = f none} ])

  -- Since Erased is (equivalent to) a function type, erasure extensionality/[]-cong
  -- is a special case of function extensionality:
  --
  --                                   funext
  -- Erased (Paths A) â‰ƒ (None â†’ Paths A) â†’ Paths (None â†’ A) â‰ƒ Paths (Erased A)
  []-cong' : []-cong-type
  []-cong' {A} {x} {y} p = cong â—‹â†’E x'â‰¡y'
    where
      x' y' : â—‹ Eâ†’â—‹ [ A ]
      x' = Eâ†’â—‹ [ x ]
      y' = Eâ†’â—‹ [ y ]

      x'â‰¡y' : x' â‰¡ y'
      x'â‰¡y' = funext (Eâ†’â—‹ p)

  -- The reflector into the corresponding *closed* subtopos of â—‹-connected types
  -- is given by the join with None, which is equivalent to the following HIT
  -- (we enter cubical land here):
  data â—_ (A : Type a) : Type a where
    -- At runtime, we only have A.
    â—-Î· : A â†’ â— A
    -- At compile time, we also have an erased "cone" that glues all of A together,
    -- so that â— A is contractible.
    @0 none : â— A
    @0 glue : (a : A) â†’ â—-Î· a ğŸ§Š.â‰¡ none

  @0 â—-â—‹-connected : âˆ€ {A : Type a} â†’ ğŸ§Š.isContr (â— A)
  â—-â—‹-connected {A} = none ğŸ§Š., cone where
    cone : (a : â— A) â†’ none ğŸ§Š.â‰¡ a
    cone (â—-Î· a) = ğŸ§Š.sym (glue a)
    cone none = ğŸ§Š.refl
    cone (glue a i) j = glue a (i ğŸ§Š.âˆ¨ ğŸ§Š.~ j)

  -- Fracture and gluing

  â—‹'-Î· : {A : Type a} â†’ A â†’ â—‹' A
  â—‹'-Î· a _ = a

  â—-map : {A : Type a} {B : Type b} â†’ (A â†’ B) â†’ â— A â†’ â— B
  â—-map f (â—-Î· a) = â—-Î· (f a)
  â—-map f none = none
  â—-map f (glue a i) = glue (f a) i

  â—‹â†’â—â—‹ : {A : Type a} â†’ â—‹' A â†’ â— â—‹' A
  â—‹â†’â—â—‹ = â—-Î·

  â—â†’â—â—‹ : {A : Type a} â†’ â— A â†’ â— â—‹' A
  â—â†’â—â—‹ = â—-map â—‹'-Î·

  module _ (A : Type a) where
    record Fracture : Type a where
      field
        op : â—‹' A
        cl : â— A
        agree : â—‹â†’â—â—‹ op ğŸ§Š.â‰¡ â—â†’â—â—‹ cl

    open Fracture

    fracture : A â†’ Fracture
    fracture a .op = â—‹'-Î· a
    fracture a .cl = â—-Î· a
    fracture a .agree = ğŸ§Š.refl

    gluing : Fracture â†’ A
    gluing f = go (f .op) (f .cl) (f .agree)
      where
        go : (op : â—‹' A) â†’ (cl : â— A) â†’ â—‹â†’â—â—‹ op ğŸ§Š.â‰¡ â—â†’â—â—‹ cl â†’ A
        go op (â—-Î· a) agree = a
        go op none agree = op none
        go op (glue a i) agree = {! ğŸ§Š.coeiâ†’0 (Î» i â†’ â—-Î· op ğŸ§Š.â‰¡ glue (Î» _ â†’ a) i) i agree   !}

    gluing-fracture : âˆ€ a â†’ gluing (fracture a) â‰¡ a
    gluing-fracture a = {!   !}

    fracture-gluing : âˆ€ f â†’ fracture (gluing f) â‰¡ f
    fracture-gluing f = {!   !}
