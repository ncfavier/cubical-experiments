{-# OPTIONS --cubical --erasure --rewriting #-}
open import Agda.Primitive renaming (Set to Type; SetÏ‰ to TypeÏ‰)
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Axiom.Extensionality.Propositional
import Cubical.Foundations.Prelude as ğŸ§Š
{-# BUILTIN REWRITE _â‰¡_ #-}

-- Investigating the erasure modality
module Erasure where

private variable
  a b : Level
  A : Type a

-- The erased path induction principle Jâ‚€

Jâ‚€-type =
  âˆ€ {a b} {@0 A : Type a} {@0 x : A} (B : (@0 y : A) â†’ @0 x â‰¡ y â†’ Type b)
  â†’ {@0 y : A} (@0 p : x â‰¡ y) â†’ B x refl â†’ B y p

-- The Erased monadic modality

record Erased (@0 A : Type a) : Type a where
  constructor [_]
  field
    @0 erased : A

open Erased

Î· : {@0 A : Type a} â†’ A â†’ Erased A
Î· x = [ x ]

Î¼ : {@0 A : Type a} â†’ Erased (Erased A) â†’ Erased A
Î¼ [ [ x ] ] = [ x ]

-- Paths (Erased A) â†’ Erased (Paths A)
erased-cong : âˆ€ {a} {@0 A : Type a} {@0 x y : A} â†’ [ x ] â‰¡ [ y ] â†’ Erased (x â‰¡ y)
erased-cong p = [ cong erased p ]

-- Erased (Paths A) â†’ Paths (Erased A) ("erasure extensionality")
[]-cong-type = âˆ€ {a} {@0 A : Type a} {@0 x y : A} â†’ Erased (x â‰¡ y) â†’ [ x ] â‰¡ [ y ]

-- Jâ‚€ and []-cong (with their respective computation rules) are interderivable

module Jâ‚€â†’[]-cong where
  postulate
    Jâ‚€ : Jâ‚€-type
    Jâ‚€-refl
      : âˆ€ {a b} {@0 A : Type a} {@0 x : A} (B : (@0 y : A) â†’ @0 x â‰¡ y â†’ Type b) (r : B x refl)
      â†’ Jâ‚€ B refl r â‰¡ r
    {-# REWRITE Jâ‚€-refl #-}

  []-cong : []-cong-type
  []-cong {x = x} [ p ] = Jâ‚€ (Î» y _ â†’ [ x ] â‰¡ [ y ]) p refl

  []-cong-refl
    : âˆ€ {a} {@0 A : Type a} {@0 x : A}
    â†’ []-cong {x = x} [ refl ] â‰¡ refl
  []-cong-refl = refl

module []-congâ†’Jâ‚€ where
  postulate
    []-cong : []-cong-type
    []-cong-refl
      : âˆ€ {a} {@0 A : Type a} {@0 x : A}
      â†’ []-cong {x = x} [ refl ] â‰¡ refl
    {-# REWRITE []-cong-refl #-}

  --                        []-cong                        Î¼
  -- Erased (Paths (Erased A)) â†’ Paths (Erased (Erased A)) â†’ Paths (Erased A)
  stable-â‰¡ : âˆ€ {@0 A : Type a} {@0 x y : Erased A} â†’ Erased (x â‰¡ y) â†’ x â‰¡ y
  stable-â‰¡ p = cong Î¼ ([]-cong p)

  --         Î·               []-cong          erased-cong
  -- Paths A â†’ Erased (Paths A) â†’ Paths (Erased A) â†’ Erased (Paths A)
  --           Erased (Paths A)           â†’          Erased (Paths A)
  --                                      id
  []-cong-section'
    : âˆ€ {@0 A : Type a} {@0 x y : A} (p : x â‰¡ y)
    â†’ erased-cong ([]-cong (Î· p)) â‰¡ Î· p
  []-cong-section' refl = refl

  -- We can cancel out Î· by unique elimination and stability of paths in Erased
  []-cong-section
    : âˆ€ {@0 A : Type a} {@0 x y : A} (@0 p : x â‰¡ y)
    â†’ erased-cong ([]-cong [ p ]) â‰¡ [ p ]
  []-cong-section p = stable-â‰¡ [ []-cong-section' p ]

  Jâ‚€ : Jâ‚€-type
  Jâ‚€ B {y} p r = subst (Î» ([ p ]) â†’ B y p) ([]-cong-section p) b'
    where
      b' : B y (cong erased ([]-cong [ p ]))
      b' = J (Î» ([ y ]) p â†’ B y (cong erased p)) ([]-cong [ p ]) r

  Jâ‚€-refl
    : âˆ€ {a b} {@0 A : Type a} {@0 x : A} (B : (@0 y : A) â†’ @0 x â‰¡ y â†’ Type b) (r : B x refl)
    â†’ Jâ‚€ B refl r â‰¡ r
  Jâ‚€-refl B r = refl

-- Function extensionality implies erasure extensionality
module funextâ†’[]-cong where
  postulate
    funext : âˆ€ {a b} â†’ Extensionality a b

  -- Direct proof, extracted from "Logical properties of a modality for erasure" (Danielsson 2019)
  []-cong : []-cong-type
  []-cong {A = A} {x} {y} [ p ] =
    cong (Î» (f : [ x ] â‰¡ [ y ] â†’ Erased (Erased A))
          â†’ [ f (cong Î· p) .erased .erased ])
         (funext (cong Î·))

  -- Alternative proof: ignoring some details, the types of funext and []-cong look very similar:
  --   funext  : Functions (Paths A) â†’ Paths (Functions A)
  --   []-cong : Erased    (Paths A) â†’ Paths (Erased    A)
  --
  -- If we have inductive types with erased constructors, then we can
  -- present erasure as an *open subtopos* generated by the subterminal
  -- object with a single erased point:

  data None : Type where
    @0 none : None

  â—‹'_ : Type a â†’ Type a
  â—‹' A = None â†’ A

  â—‹_ : â—‹' Type a â†’ Type a
  â—‹ A = (n : None) â†’ A n

  Eâ†’â—‹ : {A : â—‹' Type a} â†’ Erased (A none) â†’ â—‹ A
  Eâ†’â—‹ [ a ] none = a

  â—‹â†’E : {A : â—‹' Type a} â†’ â—‹ A â†’ Erased (A none)
  â—‹â†’E f = [ f none ]

  Eâ†’â—‹â†’E : {A : â—‹' Type a} â†’ (a : Erased (A none)) â†’ â—‹â†’E (Eâ†’â—‹ {A = A} a) â‰¡ a
  Eâ†’â—‹â†’E _ = refl

  -- We don't actually need this
  â—‹â†’Eâ†’â—‹ : {A : â—‹' Type a} â†’ (f : â—‹ A) â†’ Eâ†’â—‹ (â—‹â†’E f) â‰¡ f
  â—‹â†’Eâ†’â—‹ f = funext (Eâ†’â—‹ [ refl {x = f none} ])

  -- Since Erased is (equivalent to) a function type, erasure extensionality/[]-cong
  -- is a special case of function extensionality:
  --
  --                                   funext
  -- Erased (Paths A) â‰ƒ (None â†’ Paths A) â†’ Paths (None â†’ A) â‰ƒ Paths (Erased A)
  []-cong' : []-cong-type
  []-cong' {A = A} {x} {y} p = cong â—‹â†’E x'â‰¡y'
    where
      x' y' : â—‹ Eâ†’â—‹ [ A ]
      x' = Eâ†’â—‹ [ x ]
      y' = Eâ†’â—‹ [ y ]

      x'â‰¡y' : x' â‰¡ y'
      x'â‰¡y' = funext (Eâ†’â—‹ p)

  -- The reflector into the corresponding *closed* subtopos is given by the join with None,
  -- which is equivalent to the following HIT (we enter cubical land here):
  data â—_ (A : Type a) : Type a where
    -- At runtime, we only have A.
    inc : A â†’ â— A
    -- At compile time, we also have an erased "cone" that glues all of A together,
    -- so that â— A is contractible.
    @0 none : â— A
    @0 glue : (a : A) â†’ inc a ğŸ§Š.â‰¡ none

  -- TODO: make all this nonsense precise. realisability topoi?
